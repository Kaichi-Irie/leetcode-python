# 問題へのリンク
[Add Two Numbers - LeetCode](https://leetcode.com/problems/add-two-numbers/description/)

# 言語
Python

# 問題の概要
与えられた2つの非負整数を逆順で表現した連結リストとして受け取り、それらの合計を同様に連結リストで返す問題。

# 自分の解法
再帰関数を用いた解法。


連結リストl1, l2の長さをそれぞれ`m`, `n`とすると
- 時間計算量：`O(max(m,n))`
- 空間計算量：`O(max(m,n))`(再帰のスタック領域を含む)

## step2
再帰的な実装から反復的な実装に変えた。また、変数名もより明確なものに変更した。

- アルゴリズムの変更：再帰から反復へ
    - step1は再帰関数を用いた実装であったが、step2はwhileループを用いた反復処理の実装である。これにより、非常に長い連結リストを扱う際のスタックオーバーフローのリスクが解消された。
- ダミーヘッドノードの導入
    - step2では、連結リストを構築する際の一般的なテクニックである`dummy_head`ノードが導入された。これにより、リストの先頭ノードに関する特別な処理が不要になり、コードが単純化されている。
- `None`ノードの処理方法の改善
    - step1では、入力リストのノードが`None`の場合に新しい`ListNode`を生成していた。step2では、`l1.val if l1 else 0`という三項演算子を用いることで、この処理をより効率的かつ簡潔に記述している。
- ループ条件の単純化
    - step1の複雑な再帰終了条件は、step2では`while l1 or l2 or carry_of_digits:`という単一の明快なループ条件に集約された。これは、処理を継続すべき全てのケースを網羅している。


# 別解・模範解答
再帰関数ではなく、ループを用いてノードを1つずつ処理する解法。
最後に返すノードは連結リストの先頭ノードなので、ダミーノードを用意しておき、そこから結果の連結リストを構築する。その後、ダミーノードの次のノード（`dummy_head.next`）を返す。
ループの最中には、今自分がどのノードを処理しているかをきちんと把握しておく。コードの中でもそれが明示できるように心がける。今回ならば、while文の中で足し合わせたノードは`node.next`に保存する。

連結リストl1, l2の長さをそれぞれ`m`, `n`とすると

- 時間計算量：`O(max(m,n))`
- 空間計算量：`O(1)`

# 次に解く問題の予告

- [ ] [Evaluate Division - LeetCode](https://leetcode.com/problems/evaluate-division/description/)
